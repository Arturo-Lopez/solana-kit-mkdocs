{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Kit is a JavaScript SDK for building Solana apps across environments like Node, the web, and React Native. It provides a comprehensive set of data types and helper functions, forming the foundation for interacting with Solana in JavaScript.</p> <p>Coming from Web3.js?</p> <p>Check out our Upgrade guide to see how Kit compares to Web3.js.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Follow these simple steps to install and get started with Kit:</p>"},{"location":"#install-kit","title":"Install Kit","text":"<p>Install Kit using the main <code>@solana/kit library</code>. It includes many smaller packages \u2014 such as <code>@solana/rpc</code> or <code>@solana/transactions</code> \u2014 that can also be used individually for more granular imports.</p> npmyarnpnpmbun <pre><code>npm instal --save @solana/kit\n</code></pre> <pre><code>yarn add @solana/kit\n</code></pre> <pre><code>pnpm add @solana/kit\n</code></pre> <pre><code>bun add @solana/kit\n</code></pre>"},{"location":"#install-program-clients","title":"Install program clients","text":"<p>Install Kit compatible clients for any program you want to interact with. For example, to interact with the System program, install the <code>@solana-program/system</code> package. You can find a list of available program clients here.</p> npmyarnpnpmbun <pre><code>npm instal --save @solana-program/system \\\n    @solana-program/memo \\\n    @solana-program/token \\\n    @solana-program/compute-budget\n</code></pre> <pre><code>yarn add @solana-program/system \\\n    @solana-program/memo \\\n    @solana-program/token \\\n    @solana-program/compute-budget\n</code></pre> <pre><code>pnpm add @solana-program/system \\\n    @solana-program/memo \\\n    @solana-program/token \\\n    @solana-program/compute-budget\n</code></pre> <pre><code>bun add @solana-program/system \\\n    @solana-program/memo \\\n    @solana-program/token \\\n    @solana-program/compute-budget\n</code></pre>"},{"location":"#set-up-your-project","title":"Set up your project","text":"<p>Use primitives provided by Kit to set up your project and start interacting with Solana!</p> <p>For example, if you are planning on sending transactions, you will likely need an RPC API, an RPC Subscriptions API and a \"send and confirm\" strategy.</p> <pre><code>import {\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  sendAndConfirmTransactionFactory,\n} from \"@solana/kit\";\n\nconst rpc = createSolanaRpc(\"https://api.devnet.solana.com\");\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\n  \"wss://api.devnet.solana.com\"\n);\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n  rpc,\n  rpcSubscriptions,\n});\n</code></pre>"},{"location":"compatible-clients/","title":"Compatible clients","text":"<p>The table below provides a list of JavaScript program clients that you can use with Kit. Make sure to install the library of each program your app interacts with to access its API.</p> <p>Note that program clients are generated using Codama and you can do the same for your own program clients.</p> Program repository Library Maintainer Address Lookup Table @solana-program/address-lookup-table Anza Compute Budget @solana-program/compute-budget Anza Memo @solana-program/memo Anza Token @solana-program/token Anza Token Extension @solana-program/token-2022 Anza Stake @solana-program/stake Anza System @solana-program/system Anza"},{"location":"upgrade-guide/","title":"Upgrade Guide","text":""},{"location":"upgrade-guide/#why-upgrade","title":"Why upgrade?","text":"<p>Kit (formerly Web3.js v2) is a complete rewrite of the Web3.js library. It is designed to be more composable, customizable, and efficient than its predecessor. Its functional design enables the entire library to be tree-shaken, drastically reducing your bundle size. It also takes advantage of modern JavaScript features \u2014 such as native <code>Ed25519</code> key support and <code>bigint</code> for large values \u2014 resulting in an even smaller bundle, better performance and most importantly, a reduced attack surface for your application.</p> <p>Unlike Web3.js, Kit doesn't rely on JavaScript classes or other non-tree-shakeable features. This brings us to our first key difference.</p>"},{"location":"upgrade-guide/#wheres-my-connection-class","title":"Where's my <code>Connection</code> class?","text":"<p>In Web3.js, the <code>Connection</code> class serves as a central entry point, making the library's API easier to discover via a single object. However, this comes at a cost: using the <code>Connection</code> class forces you to bundle every method it provides, even if you only use a few. As a result, your users must download the entire library, even when most of it goes unused.</p> <p>To avoid this, Kit does not include a single entry-point class like <code>Connection</code>. Instead, it offers a set of functions that you can import and use as needed. Two key functions replace most of the <code>Connection</code> class's functionality: <code>createSolanaRpc</code> and <code>createSolanaRpcSubscriptions</code>.</p> <p>The former, <code>createSolanaRpc</code>, returns an Rpc object for making RPC requests to a specified endpoint. Read more about RPCs here.</p> Web3.js<pre><code>import { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Create a `Connection` object.\nconst connection = new Connection(\"https://api.devnet.solana.com\", {\n  commitment: \"confirmed\",\n});\n\n// Send RPC requests.\nconst wallet = new PublicKey(\"1234..5678\");\nconst balance = await connection.getBalance(wallet);\n</code></pre> Kit<pre><code>import { address, createSolanaRpc } from \"@solana/kit\";\n\n// Create an RPC proxy object.\nconst rpc = createSolanaRpc(\"https://api.devnet.solana.com\");\n\n// Send RPC requests.\nconst wallet = address(\"1234..5678\");\nconst { value: balance } = await rpc.getBalance(wallet).send();\n</code></pre> <p>The latter, <code>createSolanaRpcSubscriptions</code>, returns an <code>RpcSubscriptions</code> object, which lets you to subscribe to events on the Solana network. Read more about RPC Subscriptions here.</p> Web3.js<pre><code>import { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Create a `Connection` object with a WebSocket endpoint.\nconst connection = new Connection(\"https://api.devnet.solana.com\", {\n  wsEndpoint: \"wss://api.devnet.solana.com\",\n  commitment: \"confirmed\",\n});\n\n// Subscribe to RPC events and listen to notifications.\nconst wallet = new PublicKey(\"1234..5678\");\nconnection.onAccountChange(wallet, (accountInfo) =&gt; {\n  console.log(accountInfo);\n});\n</code></pre> Kit<pre><code>import { address, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\n// Create an RPC subscriptions proxy object.\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\n  \"wss://api.devnet.solana.com\"\n);\n\n// Use an `AbortController` to cancel the subscriptions.\nconst abortController = new AbortController();\n\n// Subscribe to RPC events.\nconst wallet = address(\"1234..5678\");\nconst accountNotifications = await rpcSubscriptions\n  .accountNotifications(wallet, { commitment: \"confirmed\" })\n  .subscribe({ abortSignal: abortController.signal });\n\ntry {\n  // Listen to event notifications.\n  for await (const accountInfo of accountNotifications) {\n    console.log(accountInfo);\n  }\n} catch (e) {\n  // Gracefully handle subscription disconnects.\n}\n</code></pre> <p>Note that, although <code>Rpc</code> and <code>RpcSubscriptions</code> look like classes, they are actually <code>Proxy</code> objects. This means they dynamically construct RPC requests or subscriptions based on method names and parameters. TypeScript is then used to provide type safety for the RPC API, making it easy to discover available RPC methods while keeping the library lightweight. Regardless of whether your RPC supports 1 method or 100, the bundle size remains unchanged.</p>"},{"location":"upgrade-guide/#fetching-and-decoding-accounts","title":"Fetching and decoding accounts","text":"<p>Now that we know how to send RPC requests, fetching one or more on-chain accounts is as simple as calling the appropriate RPC method. For example, here's how to retrieve an account using its address:</p> Web3.js<pre><code>import { PublicKey } from \"@solana/web3.js\";\n\nconst wallet = new PublicKey(\"1234..5678\");\nconst account = await connection.getAccountInfo(wallet);\n</code></pre> Kit<pre><code>import { address } from \"@solana/kit\";\n\nconst wallet = address(\"1234..5678\");\nconst { value: account } = await rpc.getAccountInfo(wallet).send();\n</code></pre> <p>Kit also provides helper functions like<code>fetchEncodedAccount</code> and <code>fetchEncodedAccounts</code>, which return <code>MaybeAccount</code> objects. These objects store the account's address and include an <code>exists</code> boolean to indicate whether the account is present on-chain. If <code>exists</code> is <code>true</code>, the object also contains the expected account info. These helpers also unify the return type of accounts, ensuring consistency regardless of the encoding used to fetch them.</p> Kit<pre><code>import { address, assertAccountExists, fetchEncodedAccount } from \"@solana/kit\";\n\nconst wallet = address(\"1234..5678\");\nconst account = await fetchEncodedAccount(rpc, wallet);\nassertAccountExists(account);\naccount.data satisfies Uint8Array;\n</code></pre> <p>In addition, Kit introduces a new serialization library called <code>codecs</code>. Codecs are composable objects for encoding and decoding any type to and from a <code>Uint8Array</code>. For example, here's how you can define a codec for a <code>Person</code> account by combining multiple codec primitives:</p> Kit<pre><code>import {\n  address,\n  Address,\n  addCodecSizePrefix,\n  Codec,\n  getAddressCodec,\n  getStructCodec,\n  getU32Codec,\n  getU8Codec,\n  getUtf8Codec,\n} from \"@solana/kit\";\n\ntype Person = {\n  age: number;\n  discriminator: number;\n  name: string;\n  wallet: Address;\n};\n\nconst personCodec: Codec&lt;Person&gt; = getStructCodec([\n  [\"discriminator\", getU8Codec()], // A single-byte account discriminator.\n  [\"wallet\", getAddressCodec()], // A 32-byte account address.\n  [\"age\", getU8Codec()], // An 8-bit unsigned integer.\n  [\"name\", addCodecSizePrefix(getUtf8Codec(), getU32Codec())], // A UTF-8 string with a 32-bit length prefix.\n]);\n\nconst bytes = personCodec.encode({\n  age: 42,\n  discriminator: 0,\n  name: \"Alice\",\n  wallet: address(\"1234..5678\"),\n});\n</code></pre> <p>You can read more about codecs here.</p> <p>Once you have a codec for an account's data, you can use the <code>decodeAccount</code> function to transform an encoded account into a decoded account.</p> Kit<pre><code>import {\n  address,\n  Codec,\n  decodeAccount,\n  fetchEncodedAccount,\n} from \"@solana/kit\";\n\nconst wallet = address(\"1234..5678\");\nconst account = await fetchEncodedAccount(rpc, wallet);\nconst decodedAccount = decodeAccount(account, personCodec);\n\nif (decodedAccount.exists) {\n  decodedAccount.data satisfies Person;\n}\n</code></pre>"},{"location":"upgrade-guide/#using-program-libraries","title":"Using program libraries","text":"<p>Fortunately, you don't need to create a custom codec every time you decode an account. Kit provides client libraries for many popular Solana programs that can help with that. For example, System program helpers are available in the <code>@solana-program/system</code> library.</p> <p>These libraries are generated via Codama, ensuring consistent structure across them. For instance, the <code>fetchNonce</code> function from <code>@solana-program/system</code> can be used to fetch and decode a <code>Nonce</code> account from its address.</p> Kit<pre><code>import { Account, address } from \"@solana/kit\";\nimport { fetchNonce, Nonce } from \"@solana-program/system\";\n\nconst account: Account&lt;Nonce&gt; = await fetchNonce(rpc, address(\"1234..5678\"));\n</code></pre> <p>Check out the \"Compatible clients\" page for a list of available program libraries compatible with Kit.</p>"},{"location":"upgrade-guide/#creating-instructions","title":"Creating instructions","text":"<p>In addition to fetching and decoding accounts, generated program clients also provide functions for creating instructions. These functions follow the <code>getXInstruction</code> naming convention, where <code>X</code> is the name of the instruction.</p> <p>For example, here's how to create a <code>CreateAccount</code> instruction using the <code>SystemProgram</code> class in Web3.js, followed by the Kit equivalent using the <code>@solana-program/system</code> library.</p> Web3.js<pre><code>import { PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nconst transferSol = SystemProgram.transfer({\n  fromPubkey: new PublicKey(\"2222..2222\"),\n  toPubkey: new PublicKey(\"3333..3333\"),\n  lamports: 1_000_000_000, // 1 SOL.\n});\n</code></pre> Kit<pre><code>import { address, createNoopSigner } from \"@solana/kit\";\nimport { getTransferSolInstruction } from \"@solana-program/system\";\n\nconst transferSol = getTransferSolInstruction({\n  source: createNoopSigner(address(\"2222..2222\")),\n  destination: address(\"3333..3333\"),\n  amount: 1_000_000_000, // 1 SOL.\n});\n</code></pre> <p>Transaction signers</p> <p>Notice the <code>createNoopSigner</code> function in the Kit example. Unlike Web3.js, Kit uses <code>TransactionSigner</code> objects when an account needs to act as a signer for an instruction. This allows signers to be extracted from built transactions, enabling automatic transaction signing without manually scanning instructions to find required signers. We'll explore this further in the \"Signing transactions\" section below.</p> <p>Now that we know how to create instructions, let's see how to use them to build transactions.</p>"},{"location":"upgrade-guide/#building-transactions","title":"Building transactions","text":"<p>Web3.js makes a number of assumptions when creating transactions. For example, it defaults to the latest transaction version and uses a recent blockhash for the transaction lifetime. While this improves the developer experience by providing sensible defaults, it comes at the cost of tree-shakeability. If an application only relies on durable nonce lifetimes, it will still be forced to bundle logic related to blockhash lifetimes, even if it's never used.</p> <p>Kit, on the other hand, makes no assumptions about transactions. Instead, it requires developers to explicitly provide all necessary information using a series of helper functions. These functions progressively transform an empty transaction message into a fully compiled and signed transaction, ready to be sent to the network. This approach ensures strong type safety, allowing helper functions to enforce valid transaction states at compile time.</p> <p>Since TypeScript cannot re-declare the type of an existing variable, each transaction helper returns a new immutable transaction object with an updated type. To streamline this, Kit provides a <code>pipe</code> function, allowing developers to chain transaction helpers together efficiently.</p> Web3.js<pre><code>import { PublicKey, SystemProgram, Transaction } from \"@solana/web3.js\";\nimport { createInitializeMintInstruction } from \"@solana/spl-token\";\n\nconst latestBlockhash = await connection.getLatestBlockhash();\nconst createAccount = SystemProgram.createAccount(createAccountInput);\nconst initializeMint = createInitializeMintInstruction(initializeMintInput);\n\nconst transaction = new Transaction({ feePayer, ...latestBlockhash })\n  .add(createAccount)\n  .add(initializeMint);\n</code></pre> Kit<pre><code>import {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getInitializeMintInstruction } from \"@solana-program/token\";\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\nconst createAccount = getCreateAccountInstruction(createAccountInput);\nconst initializeMint = getInitializeMintInstruction(initializeMintInput);\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) =&gt; setTransactionMessageFeePayerSigner(payer, tx),\n  (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) =&gt;\n    appendTransactionMessageInstructions([createAccount, initializeMint], tx)\n);\n</code></pre>"},{"location":"upgrade-guide/#signing-transactions","title":"Signing transactions","text":"<p>Both Web3.js and Kit allow keypairs to sign or partially sign transactions. However, Kit leverages the native CryptoKeyPair API to generate and export keypairs securely, without exposing private keys to the environment.</p> Web3.js<pre><code>import { Keypair, Transaction } from \"@solana/web3.js\";\n\nconst payer = Keypair.generate();\nconst authority = Keypair.generate();\n\ntransaction.sign([payer, authority]);\n</code></pre> Kit<pre><code>import {\n  compileTransaction,\n  generateKeyPair,\n  signTransaction,\n} from \"@solana/kit\";\n\nconst [payer, authority] = await Promise.all([\n  generateKeyPair(),\n  generateKeyPair(),\n]);\n\nconst transaction = compileTransaction(transactionMessage);\nconst signedTransaction = await signTransaction(\n  [payer, authority],\n  transaction\n);\n</code></pre> <p>Additionally, as mentioned in the \"Creating instructions\" section, Kit introduces signer objects. These objects handle transaction and message signing while abstracting away the underlying signing mechanism. This could be using a Crypto KeyPair, a wallet adapter in the browser, a Noop signer, or anything we want. Here are some examples of how signers can be created:</p> Kit<pre><code>import { address, createNoopSigner, generateKeyPairSigner } from \"@solana/kit\";\nimport { useWalletAccountTransactionSendingSigner } from \"@solana/react\";\n\n// Using CryptoKeyPairs.\nconst myKeypairSigner = await generateKeyPairSigner();\n\n// Using the wallet standard.\nconst myWalletSigner = useWalletAccountTransactionSendingSigner(\n  account,\n  currentChain\n);\n\n// Using a Noop signer.\nconst myNoopSigner = createNoopSigner(address(\"1234..5678\"));\n</code></pre> <p>One key advantage of using signers is that they can be passed directly when creating instructions. This enables transaction messages to be aware of the required signers, eliminating the need to manually track them. When this is the case, the <code>signTransactionMessageWithSigners</code> function can be used to sign the transaction with all attached signers.</p> <p>Here's an example of passing signers to both instructions and the transaction fee payer. Notice that <code>signTransactionMessageWithSigners</code> doesn't require additional signers to be passed in \u2014 it already knows which ones are needed.</p> Kit<pre><code>import { signTransactionMessageWithSigners } from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport {\n  getInitializeMintInstruction,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\n\n// Create signers.\nconst [payer, mint] = await Promise.all([\n  generateKeyPairSigner(),\n  generateKeyPairSigner(),\n]);\n\n// Create the instructions.\nconst createAccount = getCreateAccountInstruction({\n  payer, // &lt;- TransactionSigner\n  newAccount: mint, // &lt;- TransactionSigner\n  space,\n  lamports,\n  programAddress: TOKEN_PROGRAM_ADDRESS,\n});\nconst initializeMint = getInitializeMintInstruction({\n  mint: mint.address,\n  mintAuthority: address(\"1234..5678\"),\n  decimals: 2,\n});\n\n// Create the transaction.\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) =&gt; setTransactionMessageFeePayerSigner(payer, tx), // &lt;- TransactionSigner\n  (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) =&gt;\n    appendTransactionMessageInstructions([createAccount, initializeMint], tx)\n);\n\n// Sign the transaction.\nconst signedTransaction = await signTransactionMessageWithSigners(\n  transactionMessage\n);\n</code></pre> <p>Read more about signers here.</p>"},{"location":"upgrade-guide/#sending-and-confirming-transactions","title":"Sending and confirming transactions","text":"<p>Finally, we can send our signed transaction to the network and wait for confirmation. While there are multiple ways to confirm transactions (e.g., polling, listening for events, etc.), both Web3.js and Kit provide a default strategy that works for most use cases.</p> Web3.js<pre><code>import { Keypair, sendAndConfirmTransaction } from \"@solana/web3.js\";\n\n// Create keypairs.\nconst payer = Keypair.generate();\nconst mint = Keypair.generate();\n\n// Sign, send and confirm the transaction.\nconst transactionSignature = await sendAndConfirmTransaction(\n  connection,\n  transaction,\n  [feePayer, mint]\n);\n</code></pre> Kit<pre><code>import {\n  sendAndConfirmTransactionFactory,\n  getSignatureFromTransaction,\n} from \"@solana/kit\";\n\n// Create a send and confirm function from your RPC and RPC Subscriptions objects.\nconst sendAndConfirm = sendAndConfirmTransactionFactory({\n  rpc,\n  rpcSubscriptions,\n});\n\n// Use it to send and confirm any signed transaction.\nconst transactionSignature = getSignatureFromTransaction(signedTransaction);\nawait sendAndConfirm(signedTransaction, { commitment: \"confirmed\" });\n</code></pre> <p>Notice that the <code>sendAndConfirm</code> function does not return the transaction signature. This is because a transaction signature is deterministically known before it is sent. To access it, Kit provides a separate <code>getSignatureFromTransaction</code> helper as illustrated in the code snippet above.</p> <p>Additionally, the <code>sendAndConfirmTransactionFactory</code> function requires both an RPC and an RPC Subscriptions object. However, this does not mean that the full RPC and RPC Subscriptions implementations are needed. Only the following API methods must be implemented:</p> <ul> <li>For the <code>Rpc</code> object: <code>GetEpochInfoApi</code>, <code>GetSignatureStatusesApi</code>, and <code>SendTransactionApi</code>.</li> <li>For the <code>RpcSubscriptions</code> object: <code>SignatureNotificationsApi</code> and <code>SlotNotificationsApi</code>.</li> </ul>"},{"location":"upgrade-guide/#closing-words","title":"Closing words","text":"<p>We've now explored the key differences between Web3.js and Kit, giving you a solid foundation for upgrading your project. Since Kit is a complete rewrite, there's no simple step-by-step migration guide, and the process may take some time.</p> <p>To ease the transition, Kit provides a <code>@solana/compat</code> package, which allows for incremental migration. This package includes functions that convert core types \u2014 such as public keys and transactions \u2014 between Web3.js and Kit. This means you can start integrating Kit without having to refactor your entire project at once.</p> Kit<pre><code>import { Keypair, PublicKey } from \"@solana/web3.js\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\nimport {\n  fromLegacyKeypair,\n  fromLegacyPublicKey,\n  fromLegacyTransactionInstruction,\n  fromVersionedTransaction,\n} from \"@solana/compat\";\n\n// Convert `PublicKeys`.\nconst address = fromLegacyPublicKey(new PublicKey(\"1234..5678\"));\n\n// Convert `Keypairs`.\nconst cryptoKeypair = await fromLegacyKeypair(Keypair.generate());\nconst signer = await createSignerFromKeyPair(cryptoKeypair);\n\n// Convert `TransactionInstruction`.\nconst instruction = fromLegacyTransactionInstruction(transactionInstruction);\n\n// Convert `VersionedTransaction`.\nconst transaction = fromVersionedTransaction(versionedTransaction);\n</code></pre>"},{"location":"getting-started/build-transaction/","title":"Build a transaction","text":""},{"location":"getting-started/build-transaction/#an-immutable-affair","title":"An immutable affair","text":"<p>Before we start building our transaction, let's take a moment to discuss immutability in TypeScript. This is relevant for understanding how we can build transaction messages in a functional way.</p> <p>Consider the following mutable variable:</p> <pre><code>let person = { name: \"Alice\" };\n</code></pre> <p>As you can see by hovering on top of the <code>person</code> variable, TypeScript assigns the type <code>{ name: string }</code> to it. Now imagine we wanted to gradually grow this type by adding more properties to it. Say we wanted to add an <code>age</code> and a <code>wallet</code> property to it by using the following functions:</p> <pre><code>import { Address } from \"@solana/kit\";\n\nconst setAge = &lt;T extends object&gt;(age: number, p: T) =&gt; ({ ...p, age });\nconst setWallet = &lt;T extends object&gt;(wallet: Address, p: T) =&gt; ({\n  ...p,\n  wallet,\n});\n</code></pre> <p>One way to tackle this is to mutate the variable at each step like so.</p> <pre><code>import { address, Address } from \"@solana/kit\";\n\nlet person = { name: \"Alice\" };\nperson = setAge(30, person);\nperson = setWallet(address(\"1234..5678\"), person);\n\nperson satisfies { name: string; age: number; wallet: Address };\n//  Type '{ name: string; }' does not satisfy the expected type '{ name: string; age: number; wallet: Address; }'.\n//    Type '{ name: string; }' is missing the following properties from type '{ name: string; age: number; wallet: Address; }': age, wallet\n</code></pre> <p>But as you can see, even after updating our variable, TypeScript still believes the <code>person</code> variable is of type <code>{ name: string }</code>. This is because TypeScript doesn't re-assign types to variables when they are mutated.</p> <p>Fortunately, the Kit library offers a functional API which means its types are designed to be immutable. So, instead of trying to grow the <code>person</code> variable by mutating it, it creates new variables with new types at each step.</p> <pre><code>import { address, Address } from \"@solana/kit\";\n\nconst person = { name: \"Alice\" };\nconst personWithAge = setAge(30, person);\nconst personWithAgeAndWallet = setWallet(address(\"1234..5678\"), personWithAge);\n\npersonWithAgeAndWallet satisfies { name: string; age: number; wallet: Address };\n</code></pre> <p>The downside is we now need to create a new variable at each step. This is where the <code>pipe</code> function comes in. It takes a starting value and runs it through a series of functions, one after the other, returning the final result. This lets us build up the value and its type without needing extra variables.'</p> <pre><code>import { pipe, address, Address } from \"@solana/kit\";\n\nconst person = pipe(\n  { name: \"Alice\" },\n  (p) =&gt; setAge(30, p),\n  (p) =&gt; setWallet(address(\"1234..5678\"), p)\n);\n\nperson satisfies { name: string; age: number; wallet: Address };\n</code></pre> <p>This is exactly how we'll build our transaction in the following sections. Similarly to this person example, transaction messages can grow in a variety of ways and the ability to use composable functions to gradually construct them is a powerful tool.</p> <p>With that in mind, let's start building our transaction message, starting with the initial value of our <code>pipe</code>.</p>"},{"location":"getting-started/build-transaction/#create-the-base-transaction-message","title":"Create the base transaction message","text":"<p>The first step in building a transaction is to create a new empty transaction message. This message will eventually contain all the necessary information to send a transaction to the Solana network before being compiled and signed.</p> <p>To create one, we can use the <code>createTransactionMessage</code> function. This function requires a <code>version</code> parameter which is used to determine the format of the transaction. At the time of writing, <code>0</code> is the latest version available so we'll use that.</p> <pre><code>import { createTransactionMessage, pipe } from \"@solana/kit\";\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 })\n  // Customize the transaction message using helper functions here...\n);\n</code></pre>"},{"location":"getting-started/build-transaction/#set-the-fee-payer","title":"Set the fee payer","text":"<p>Next, we need to set a fee payer for our transaction. This is the wallet that will pay for the transaction to be sent to the network. For this, we can use the <code>setTransactionMessageFeePayerSigner</code> function which requires a <code>TransactionSigner</code> object. Since we already have a signer in our <code>Client</code> object, let's use it.</p> <pre><code>import { createTransactionMessage, pipe, setTransactionMessageFeePayerSigner } from \"@solana/kit\";\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n+ (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n);\n</code></pre>"},{"location":"getting-started/build-transaction/#set-the-transaction-lifetime","title":"Set the transaction lifetime","text":"<p>We also need to specify a lifetime for our transaction. This lifetime defines a period of time during which the transaction is valid.</p> <p>There are currently two lifetime strategies available:</p> <ul> <li>The blockhash strategy: Given a block height \u2014 i.e. number of blocks since the genesis block \u2014 the transaction will be valid until the next block at the given height is produced. This is the most common strategy.</li> <li>The durable nonce strategy: This strategy requires setting up a durable nonce account and advancing its value in the first instruction of the transaction. This is useful for transactions that need to be valid for long periods of time.</li> </ul> <p>For this tutorial, we'll use the blockhash strategy. To do this, we can use the <code>setTransactionMessageLifetimeUsingBlockhash</code> function which requires an object with a recent blockhash and a block height. Fortunately, this is exactly what the <code>getLatestBlockhash</code> RPC method provides.</p> <pre><code>  import {\n    createTransactionMessage,\n    pipe,\n    setTransactionMessageFeePayerSigner,\n    setTransactionMessageLifetimeUsingBlockhash,\n  } from \"@solana/kit\";\n\n+ const { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\n  const transactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n+   (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n</code></pre>"},{"location":"getting-started/build-transaction/#add-instructions","title":"Add instructions","text":"<p>Last but not least, we need to add our instructions to the transaction message. Since we've already built our instructions in the previous article, we can add them to our transaction message using the <code>appendTransactionMessageInstructions</code> function like so.</p> <pre><code>  import {\n    appendTransactionMessageInstructions,\n    createTransactionMessage,\n    pipe,\n    setTransactionMessageFeePayerSigner,\n    setTransactionMessageLifetimeUsingBlockhash,\n  } from \"@solana/kit\";\n\n  const { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\n  const transactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n    (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n+   (tx) =&gt; appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n  );\n</code></pre>"},{"location":"getting-started/build-transaction/#set-the-compute-limit-dynamically","title":"Set the compute limit dynamically","text":"<p>As mentioned in the previous article, setting a compute limit on a transaction as close as possible to the actual cost of running it will have many benefits, such as: increasing the likelihood of the transaction being scheduled, increasing the number of transactions that can be produced in a block and reducing the price of your priority fees, if any.</p> <p>A good way to estimate how much compute unit a transaction will need is to simulate it and measure its cost. This can be done using the <code>getComputeUnitEstimateForTransactionMessageFactory</code> function from <code>@solana/kit</code> to get the estimated compute limit before setting it on the transaction message using the <code>getSetComputeUnitLimitInstruction</code> function from <code>@solana-program/compute-budget</code>. Note that this must be done after the transaction message is fully configured to ensure the estimate is as accurate as possible.</p> <pre><code>import {\n  getComputeUnitEstimateForTransactionMessageFactory,\n  prependTransactionMessageInstruction,\n} from \"@solana/kit\";\nimport { getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\n\n// Build the function to estimate compute units.\nconst estimateComputeUnitLimit =\n  getComputeUnitEstimateForTransactionMessageFactory({ rpc: client.rpc });\n\n// Estimate compute units.\nconst computeUnitsEstimate = await estimateComputeUnitLimit(transactionMessage);\n\n// Prepend the compute unit limit instruction to the transaction message.\nconst transactionMessageWithComputeUnitLimit =\n  prependTransactionMessageInstruction(\n    getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n    transactionMessage\n  );\n</code></pre> <p>Since this is a common operation, let's add a helper function to our <code>Client</code> type so we can reuse it any time we need to set a compute unit limit. First, let's update the <code>Client</code> type so it offers an <code>estimateAndSetComputeUnitLimit</code> function like so.</p> src/client.ts<pre><code>  import {\n+   CompilableTransactionMessage,\n    // ...\n  } from \"@solana/kit\";\n\n  export type Client = {\n+   estimateAndSetComputeUnitLimit: &lt;T extends CompilableTransactionMessage&gt;(transactionMessage: T) =&gt; Promise&lt;T&gt;;\n    rpc: Rpc&lt;SolanaRpcApi&gt;;\n    rpcSubscriptions: RpcSubscriptions&lt;SolanaRpcSubscriptionsApi&gt;;\n    wallet: TransactionSigner &amp; MessageSigner;\n  };\n</code></pre> <p>Next, we'll implement this function in the <code>createClient</code> method by adding the following code:</p> <pre><code>  import {\n+   getComputeUnitEstimateForTransactionMessageFactory,\n+   prependTransactionMessageInstruction,\n    // ...\n  } from \"@solana/kit\";\n+ import { getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\n\n  let client: Client | undefined;\n  export async function createClient(): Promise&lt;Client&gt; {\n    if (!client) {\n      // ...\n\n+     // Create a function to estimate and set the compute unit limit.\n+     const estimateComputeUnitLimit = getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n      const estimateAndSetComputeUnitLimit = async &lt;T extends CompilableTransactionMessage&gt;(transactionMessage: T) =&gt; {\n+       const computeUnitsEstimate = await estimateComputeUnitLimit(transactionMessage);\n        return prependTransactionMessageInstruction(\n+         getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n+         transactionMessage,\n+       );\n+     };\n\n      // Store the client.\n      client = { estimateAndSetComputeUnitLimit, rpc, rpcSubscriptions, wallet };\n    }\n    return client;\n  }\n</code></pre> <p>Finally, we can now use this new <code>estimateAndSetComputeUnitLimit</code> helper at the end of our <code>pipe</code> call to set the compute unit limit on our transaction message. Note that, since <code>estimateAndSetComputeUnitLimit</code> is asynchronous, we now need to await on the return value of our <code>pipe</code>.</p> <pre><code>  import {\n    appendTransactionMessageInstructions,\n    createTransactionMessage,\n    pipe,\n    setTransactionMessageFeePayerSigner,\n    setTransactionMessageLifetimeUsingBlockhash,\n  } from \"@solana/kit\";\n\n  const { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\n  const transactionMessage = await pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n    (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    (tx) =&gt; appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n+   (tx) =&gt; client.estimateAndSetComputeUnitLimit(tx),\n  );\n</code></pre>"},{"location":"getting-started/build-transaction/#sign-the-transaction-message","title":"Sign the transaction message","text":"<p>Our transaction message is now fully configured and ready to be signed. Since we have been providing signer objects every step of the way, our transaction message already knows how to sign itself. All that is left to do is call <code>signTransactionMessageWithSigners</code>. This helper function will extract and deduplicate all the signers from the transaction message and use them to sign the message. As the message is signed, it is compiled into a new <code>Transaction</code> type that contains the compiled message and all of its signatures.</p> <pre><code>import { signTransactionMessageWithSigners } from \"@solana/kit\";\n\nconst signedTransaction = await signTransactionMessageWithSigners(\n  transactionMessage\n);\n</code></pre>"},{"location":"getting-started/build-transaction/#the-createmint-helper","title":"The <code>createMint</code> helper","text":"<p>And we finally have our fully signed transaction! In the next article, we'll learn how to send it and wait for its confirmation but before we do, here's our updated <code>createMint</code> function including everything we've learned so far.</p> src/create-mint.ts<pre><code>import {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  generateKeyPairSigner,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport {\n  getInitializeMintInstruction,\n  getMintSize,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(\n  client: Client,\n  options: { decimals?: number } = {}\n) {\n  // Prepare inputs.\n  const mintSize = getMintSize();\n  const [mint, mintRent, { value: latestBlockhash }] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n    client.rpc.getLatestBlockhash().send(),\n  ]);\n\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n  const initializeMintIx = getInitializeMintInstruction({\n    mint: mint.address,\n    decimals: options.decimals ?? 0,\n    mintAuthority: client.wallet.address,\n    freezeAuthority: client.wallet.address,\n  });\n\n  // Build the transaction message.\n  const transactionMessage = await pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n    (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    (tx) =&gt;\n      appendTransactionMessageInstructions(\n        [createAccountIx, initializeMintIx],\n        tx\n      ),\n    (tx) =&gt; client.estimateAndSetComputeUnitLimit(tx)\n  );\n\n  // Compile the transaction message and sign it.\n  const signedTransaction = await signTransactionMessageWithSigners(\n    transactionMessage\n  );\n\n  // Send the transaction and wait for confirmation.\n  // TODO: Next article!\n}\n</code></pre>"},{"location":"getting-started/create-instructions/","title":"Create instructions","text":""},{"location":"getting-started/create-instructions/#a-new-token","title":"A new token","text":"<p>Now that our <code>Client</code> helper is ready, let's use it to build a new transaction. In this tutorial, we'll build a simple transaction that creates a new Solana token using the Token program.</p> <p>More precisely, we will create a <code>Mint</code> account which is the main account that represents a Solana token. We will need at least two instructions to create a new <code>Mint</code> account:</p> <ul> <li>The <code>CreateAccount</code> instruction of the System program. This will allocate a new account on the Solana blockchain and assign it to the Token program.</li> <li>The <code>InitializeMint</code> instruction of the Token program. This will initialize the previously allocated account as a new <code>Mint</code> account.</li> </ul>"},{"location":"getting-started/create-instructions/#the-createmint-helper","title":"The <code>createMint</code> helper","text":"<p>Before we start constructing these instructions, let's create a new <code>create-mint.ts</code> file under our <code>src</code> directory. We'll export a <code>createMint</code> function that will be responsible for building and sending the transaction that creates a new <code>Mint</code> account.</p> <p>We'll accept our <code>Client</code> object as the first argument and some options as the second argument. To keep things simple, we'll only support customizing the number of decimals for the new <code>Mint</code> account.</p> src/create-mint.ts<pre><code>import type { Client } from \"./client\";\n\nexport async function createMint(\n  client: Client,\n  options: { decimals?: number } = {}\n) {\n  // ...\n}\n</code></pre> <p>Next, let's start building our instructions inside that <code>createMint</code> helper.</p>"},{"location":"getting-started/create-instructions/#the-createaccount-instruction","title":"The <code>CreateAccount</code> instruction","text":"<p>To allocate a new account on the Solana blockchain, we need to use the <code>CreateAccount</code> instruction of the System program. We can build this instruction using the <code>getCreateAccountInstruction</code> helper from the <code>@solana-program/system</code> library.</p> src/create-mint.ts<pre><code>import { getCreateAccountInstruction } from \"@solana-program/system\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(\n  client: Client,\n  options: { decimals?: number } = {}\n) {\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer,\n    newAccount,\n    space,\n    lamports,\n    programAddress,\n  });\n}\n</code></pre> <p>As you can see, the <code>getCreateAccountInstruction</code> helper requires a handful of inputs that we need to provide:</p> <ul> <li>The <code>payer</code> signer that will pay for the storage fees of the newly allocated account. In our case, we'll use the <code>wallet</code> signer of our <code>Client</code> object.   <pre><code>const payer = client.wallet;\n</code></pre></li> <li>The <code>newAccount</code> itself as a signer. Since this can be any address, we'll generate a new one and save it as a <code>mint</code> variable.   <pre><code>import { generateKeyPairSigner } from \"@solana/kit\";\nconst mint = await generateKeyPairSigner();\n</code></pre></li> <li>The <code>space</code> we want to allocated for the new account. For this, we can use the <code>getMintSize</code> helper from the <code>@solana-program/token</code> library.   <pre><code>import { getMintSize } from \"@solana-program/token\";\nconst mintSize = getMintSize();\n</code></pre></li> <li>The number of <code>lamports</code> to transfer to the new account in order to pay for the storage fees. This can be deduced from the size we want to allocate for the account by using <code>getMinimumBalanceForRentExemption</code> RPC method. This method returns the minimum lamports required for an account of the given size.   <pre><code>const mintRent = await client.rpc\n  .getMinimumBalanceForRentExemption(BigInt(mintSize))\n  .send();\n</code></pre></li> <li>The <code>programAddress</code> of the program that will own the new account. In our case, that's the Token program whose address is accessible via the <code>TOKEN_PROGRAM_ADDRESS</code> constant of the <code>@solana-program/token</code> library.   <pre><code>import { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nconst programAddress = TOKEN_PROGRAM_ADDRESS;\n</code></pre></li> </ul> <p>We end up with the following code. Notice how we wrapped a few promises that could be executed in parallel in a <code>Promise.all</code> to make the code more efficient.</p> src/create-mint.ts<pre><code>import { generateKeyPairSigner } from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getMintSize, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(\n  client: Client,\n  options: { decimals?: number } = {}\n) {\n  // Prepare inputs.\n  const mintSize = getMintSize();\n  const [mint, mintRent] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n  ]);\n\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n}\n</code></pre>"},{"location":"getting-started/create-instructions/#the-initializemint-instruction","title":"The <code>InitializeMint</code> instruction","text":"<p>Now that we have an empty account allocated on chain, let's initialize it as a Mint account. For that, we can use the getInitializeMintInstruction helper from the <code>@solana-program/token</code> library.</p> <pre><code>import { getInitializeMintInstruction } from \"@solana-program/token\";\n\nconst initializeMintIx = getInitializeMintInstruction({\n  mint,\n  decimals,\n  mintAuthority,\n  freezeAuthority,\n});\n</code></pre> <p>This time, the instruction requires we provide the following inputs:</p> <ul> <li>The address of the <code>mint</code> account we just allocated. Since we already generated a new <code>mint</code> signer, we just need to provide <code>mint.address</code>.</li> <li>The number of <code>decimals</code> for the new Mint account. We'll use the <code>options.decimals</code> argument or default to <code>0</code>.</li> <li>The authority that can mint new tokens. Here, we'll use the <code>wallet</code> signer of our <code>Client</code> object.</li> <li>The optional authority that can freeze tokens. Let's also use the <code>wallet</code> signer for this.</li> </ul> <p>We end up with the following code:</p> src/create-mint.ts<pre><code>import { generateKeyPairSigner } from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport {\n  getInitializeMintInstruction,\n  getMintSize,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(\n  client: Client,\n  options: { decimals?: number } = {}\n) {\n  // Prepare inputs.\n  const mintSize = getMintSize();\n  const [mint, mintRent] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n  ]);\n\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n  const initializeMintIx = getInitializeMintInstruction({\n    mint: mint.address,\n    decimals: options.decimals ?? 0,\n    mintAuthority: client.wallet.address,\n    freezeAuthority: client.wallet.address,\n  });\n}\n</code></pre>"},{"location":"getting-started/create-instructions/#compute-budget-instructions","title":"Compute budget instructions","text":"<p>On top of any instructions we might need in our transactions, we may also use instructions from the Compute Budget program to configure our transaction's compute allocation. For instance, we may use the <code>SetComputeUnitLimit</code> instruction to set the maximum number of compute units (CUs) that our transaction can consume. The lower that number is, the higher the chances that our transaction will be included in the next block. Additionally, the <code>SetComputeUnitPrice</code> instruction can be used to provide additional priority fees for our transactions in the form of micro-lamports per CU.</p> <p>If we wanted to include these instructions explicitly in our transaction, we could use the <code>getSetComputeUnitLimitInstruction</code> and <code>getSetComputeUnitPriceInstruction</code> helpers from the <code>@solana-program/compute-budget</code> library.</p> <pre><code>import {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"@solana-program/compute-budget\";\n\nconst setComputeLimitIx = getSetComputeUnitLimitInstruction({\n  units: 50_000, // 50k CUs per transaction.\n});\nconst setComputePriceIx = getSetComputeUnitPriceInstruction({\n  microLamports: 10_000, // 10k micro-lamports per CU, as priority fees.\n});\n</code></pre> <p>However, for this tutorial, we won't set up priority fees and we will use another helper to estimate the compute unit our transaction will consume by simulating it. We will tackle this \u2014 as well as the transaction message construction \u2014 in the next article.</p>"},{"location":"getting-started/fetch-an-account/","title":"Fetch an account","text":"<p>In the previous article of this series, we've learned how to send a transaction that creates a new Solana token \u2014 also known as a <code>Mint</code> account. In this last article, we'll learn how to retrieve the account we created and access its decoded data.</p>"},{"location":"getting-started/fetch-an-account/#fetch-using-rpc-methods","title":"Fetch using RPC methods","text":"<p>RPC methods such as <code>getAccountInfo</code> or <code>getMultipleAccounts</code> can be used to fetch on-chain accounts from their addresses. These take a variety of options and return different outputs based on these options. For instance, the <code>encoding</code> option will determine which string format to use when returning the account's encoded data.</p> <pre><code>import { address } from \"@solana/kit\";\n\nconst { value: account } = await rpc\n  .getAccountInfo(address(\"1234..5678\"))\n  .send();\nconst { value: accounts } = await rpc\n  .getMultipleAccounts([address(\"1234..5678\")])\n  .send();\n</code></pre>"},{"location":"getting-started/fetch-an-account/#fetch-using-helpers","title":"Fetch using helpers","text":"<p>Having so many possible return values makes it harder to work with the retrieved information. For instance, the <code>getAccountInfo</code> RPC method will default to a Base58 encoding whereas the <code>getMultipleAccounts</code> method will default to Base64.</p> <p>Additionally, when trying to fetch an account that does not exist on-chain, the <code>null</code> value is returned which is particularly inconvenient when dealing with multiple accounts as it requires zipping the address array with the account array to determine which ones are missing.</p> <p>Therefore, Kit offers a set of types and helpers that aim to unify these APIs and make them easier to work with. For instance, the <code>fetchEncodedAccount</code> and <code>fetchEncodedAccounts</code> helpers can be used to fetch one or multiple accounts and return them in a unified format.</p> <pre><code>import {\n  address,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  MaybeEncodedAccount,\n} from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nconst accounts = await fetchEncodedAccounts(rpc, [address(\"1234..5678\")]);\n\naccount satisfies MaybeEncodedAccount;\naccounts satisfies MaybeEncodedAccount[];\n</code></pre> <p>As you can see, the return types are all <code>MaybeAccounts</code>. This means the account may or may not exist on-chain. It contains an <code>exists</code> field indicating whether the account exists. If it does, we have access to all its fields. Otherwise, we just know its address \u2014 since it was provided as an input.</p> <pre><code>import {\n  EncodedAccount,\n  address,\n  Address,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n} from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\n\nif (account.exists) {\n  // If it exists, we have access to all its fields.\n  account satisfies EncodedAccount&lt;\"1234..5678\"&gt;;\n} else {\n  // Otherwise, we just know its address.\n  account satisfies { address: Address&lt;\"1234..5678\"&gt;; exists: false };\n}\n</code></pre> <p>We can also assert the existence of an account using the <code>assertAccountExists</code> helper. This will throw an error if the account does not exist and tell TypeScript that our <code>MaybeAccount</code> is actually an <code>Account</code> moving forward.</p> <pre><code>import {\n  assertAccountExists,\n  EncodedAccount,\n  address,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n} from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\naccount satisfies EncodedAccount;\n</code></pre>"},{"location":"getting-started/fetch-an-account/#decode-the-data-manually","title":"Decode the data manually","text":"<p>So far, we have been dealing with encoded accounts, meaning the <code>data</code> field of the fetched account is a byte array \u2014 i.e. a <code>Uint8Array</code>. But we are realistically going to need to decode that data into a more usable format.</p> <p>Kit ships with a set of serialization libraries called Codecs. These libraries offer types and functions to create Codec objects that can be composed together to create more complex serialization and deserialization logic.</p> <p>You can read more about Codecs here, but let's quickly see how we can create a Codec object to decode our <code>Mint</code> account.</p> <p>Mint accounts are composed of the following data:</p> <ul> <li>A <code>mintAuthority</code> which is an optional address. When set, this address can mint new tokens.</li> <li>A <code>supply</code> integer using a <code>u64</code>. This keeps track of the total supply of tokens.</li> <li>A <code>decimals</code> integer using a <code>u8</code>. This keeps track of the number of decimal places for the token.</li> <li>An <code>isInitialized</code> boolean using a single byte. This tells us whether the mint account has been initialized.</li> <li>A <code>freezeAuthority</code> which is an optional address. When set, this address can freeze token accounts.</li> </ul> <p>By composing various Codec functions \u2014 such as <code>getStructCodec</code> to create objects or <code>getOptionCodec</code> to create optional data \u2014 we can design a Codec object that describes the byte layout of the <code>Mint</code> account. Here's an example illustrating that. Note that the layout of the Mint account was slightly simplified for this example.</p> <pre><code>import {\n  address,\n  Address,\n  assertAccountExists,\n  fetchEncodedAccount,\n  getAddressCodec,\n  getBooleanCodec,\n  getOptionCodec,\n  getStructCodec,\n  getU64Codec,\n  getU8Codec,\n  Option,\n} from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\nconst mintCodec = getStructCodec([\n  [\"mintAuthority\", getOptionCodec(getAddressCodec())], // [simplified]\n  [\"supply\", getU64Codec()],\n  [\"decimals\", getU8Codec()],\n  [\"isInitialized\", getBooleanCodec()],\n  [\"freezeAuthority\", getOptionCodec(getAddressCodec())], // [simplified]\n]);\n\nconst decodedData = mintCodec.decode(account.data);\ndecodedData satisfies {\n  mintAuthority: Option&lt;Address&gt;;\n  supply: bigint;\n  decimals: number;\n  isInitialized: boolean;\n  freezeAuthority: Option&lt;Address&gt;;\n};\n</code></pre>"},{"location":"getting-started/fetch-an-account/#decode-using-program-clients","title":"Decode using program clients","text":"<p>Fortunately for us, we often don't need to manually create these Codec objects as program clients will provide them for us. These helpers are typically generated via Codama IDLs and follow the <code>getXCodec</code> naming convention where <code>X</code> is the name of the account.</p> <p>For instance, here's how we can access the Mint codec from the <code>@solana-program/token</code> library.</p> <pre><code>import { address, assertAccountExists, fetchEncodedAccount } from \"@solana/kit\";\nimport { getMintCodec, Mint } from \"@solana-program/token\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\nconst mintCodec = getMintCodec();\nconst decodedData = mintCodec.decode(account.data);\ndecodedData satisfies Mint;\n</code></pre> <p>This can be simplified even further by using the <code>decodeX</code> helpers from program clients. These helpers accept an <code>EncodedAccount</code> or a <code>MaybeEncodedAccount</code> and return an <code>Account&lt;T&gt;</code> or a<code>MaybeAccount&lt;T&gt;</code> respectively, where <code>T</code> is the type of the account data.</p> <pre><code>import {\n  Account,\n  address,\n  assertAccountExists,\n  fetchEncodedAccount,\n} from \"@solana/kit\";\nimport { decodeMint, Mint } from \"@solana-program/token\";\n\nconst account = decodeMint(\n  await fetchEncodedAccount(rpc, address(\"1234..5678\"))\n);\nassertAccountExists(account);\naccount satisfies Account&lt;Mint&gt;;\n</code></pre>"},{"location":"getting-started/fetch-an-account/#fetch-and-decode-using-program-clients","title":"Fetch and decode using program clients","text":"<p>Last but not least, it is possible to fetch and decode an account in a single step using the <code>fetchX</code> helpers from program clients. These helpers accept an <code>Rpc</code> object and an <code>Address</code> and return an <code>Account&lt;T&gt;</code> where <code>T</code> is the type of the account data. These helpers will also assert the existence of the account and throw an error if it does not exist.</p> <p>This means, everything we've been doing so far can be simplified into a single line of code.</p> <pre><code>import { Account, address } from \"@solana/kit\";\nimport { fetchMint, Mint } from \"@solana-program/token\";\n\nconst account = await fetchMint(rpc, address(\"1234..5678\"));\naccount satisfies Account&lt;Mint&gt;;\n</code></pre>"},{"location":"getting-started/fetch-an-account/#update-indexts","title":"Update <code>index.ts</code>","text":"<p>Now that we know how to fetch and decode on-chain accounts, let's update our main <code>tutorial</code> function to fetch the <code>Mint</code> account we created in the previous article and display its decoded data.</p> <p>Since some of its data is optional, we'll use the <code>unwrapOption</code> helper to convert <code>Option&lt;T&gt;</code> types into <code>T | null</code> before displaying them.</p> <pre><code>+ import { unwrapOption } from \"@solana/kit\";\n+ import { fetchMint } from \"@solana-program/token\";\n\n  import { createClient } from \"./client\";\n  import { createMint } from \"./create-mint\";\n\n  async function tutorial() {\n    const client = await createClient();\n    const mintAddress = await createMint(client, { decimals: 2 });\n+   const mintAccount = await fetchMint(client.rpc, mintAddress);\n    console.log(`Mint created: ${mintAddress}.`);\n+   console.log(`Mint lamports: ${mintAccount.lamports}.`);\n+   console.log(`Mint authority: ${unwrapOption(mintAccount.data.mintAuthority)}.`);\n+   console.log(`Mint decimals: ${mintAccount.data.decimals}.`);\n+   console.log(`Mint supply: ${mintAccount.data.supply}.`);\n  }\n</code></pre> <p>You should now see the following output when you run the <code>start</code> script:</p> <pre><code>Mint created: 4txHAwAuUDJAdzuNnfaL88kj4hF7wa3U3kak91r4keju.\nMint lamports: 1461600.\nMint authority: 9QR4w82jYj2eSVdzLprHZwrgEReFCGQNRPrBN2v8BCBG.\nMint decimals: 2.\nMint supply: 0.\n</code></pre>"},{"location":"getting-started/fetch-an-account/#next-steps","title":"Next steps","text":"<p>Congrats on completing this tutorial! You've learned how to get started with the Kit library by:</p> <ul> <li>Creating a <code>Client</code> object containing all the bits from Kit that matter for your application \u2014 ensuring the rest can be tree-shaken away.</li> <li>Building instructions and transaction messages.</li> <li>Generating signer objects and using them to sign transactions.</li> <li>Sending transactions and waiting for them to be confirmed.</li> <li>Fetching and decoding on-chain accounts that were created by your transactions.</li> </ul> <p>If you'd like to dig deeper into the Kit library, you may be interested in the Core concepts section of the documentation. There, you'll find in-depth articles about specific parts of the library such as Codecs, Signers, and RPCs.</p>"},{"location":"getting-started/generate-signer/","title":"Generate a signer","text":"<p>Before we can start crafting transactions, we're going to need a wallet that can sign transactions and pay for fees. In this article, we'll explore how to generate new keypairs and how to airdrop some lamports to them in test environments.</p>"},{"location":"getting-started/generate-signer/#generate-a-new-cryptokeypair","title":"Generate a new <code>CryptoKeypair</code>","text":"<p>The Kit library uses the native Crypto API for cryptographic tasks like generating key pairs and signing or verifying messages. This improves security by leveraging the browser's built-in functions instead of third-party libraries.</p> <p>To create a new keypair, you can use the <code>generateKeyPair</code> helper function. This will return an instance of the native <code>CryptoKeyPair</code> type.</p> <pre><code>import { generateKeyPair } from \"@solana/kit\";\n\nconst wallet: CryptoKeyPair = await generateKeyPair();\n</code></pre> <p>And just like that, we have a wallet that can be used to sign transactions. However, Kit provides a useful abstraction on top of anything that can sign messages and/or transactions called <code>Signers</code>.</p>"},{"location":"getting-started/generate-signer/#generate-a-new-keypairsigner","title":"Generate a new <code>KeyPairSigner</code>","text":"<p>Using <code>CryptoKeyPairs</code> is one way to sign and verify transactions but it isn't the only way. What if I want my transactions to be signed by an in-browser wallet? What if I want to sign them using a hardware wallet instead? What about a multisig wallet? Or what if I want some custom logic that detects the best way to sign a transaction based on the current environment?</p> <p>The <code>Signer</code> API allows us to decouple the signing logic from the rest of our code by providing signer interfaces that can be leveraged throughout the library. A <code>Signer</code> is an object that holds an <code>Address</code> and implements its own signing logic for messages and transactions.</p> <p>Different types of signers are available for various use cases, but in this tutorial, we'll focus on the <code>KeyPairSigner</code> which signs transactions and messages using a <code>CryptoKeyPair</code>. It implements the <code>TransactionSigner</code> and <code>MessageSigner</code> interfaces so any function that requires a transaction or message signer will be able to use it.</p> <p>We can use the <code>generateKeyPairSigner</code> function to create a new <code>KeyPairSigner</code> instance like so.</p> <pre><code>import { generateKeyPairSigner } from \"@solana/kit\";\n\nconst wallet = await generateKeyPairSigner();\n</code></pre> <p>As you can see, this is very similar to generating a <code>CryptoKeyPair</code>, but now we have an abstracted <code>Signer</code> object that can be replaced with any other type of signer in the future without affecting the rest of our code.</p> <p>For instance, here's how we could replace our <code>KeyPairSigner</code> with a signer that uses an in-browser wallet instead.</p> <pre><code>  import {\n    generateKeyPairSigner,\n    KeyPairSigner,\n    TransactionSigner,\n  } from \"@solana/kit\";\n  import { useWalletAccountTransactionSendingSigner } from \"@solana/react\";\n\n  let wallet: TransactionSigner;\n- wallet = await generateKeyPairSigner();\n+ wallet = useWalletAccountTransactionSendingSigner(account, currentChain);\n</code></pre> <p>For a deeper dive into the Signer API, check out this in-depth article about signers.</p>"},{"location":"getting-started/generate-signer/#airdrop-lamports","title":"Airdrop lamports","text":"<p>Now that we know how to generate a new signer, let's make sure we give it some lamports so it can pay for transaction fees and account storage. For that we can use the <code>airdropFactory</code> function. Given an RPC and RPC subscriptions object, it will return a function that can be used to airdrop lamports to any address \u2014 provided we are in a test environment such as localnet.</p> <pre><code>import {\n  airdropFactory,\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  generateKeyPairSigner,\n  lamports,\n} from \"@solana/kit\";\n\n// Create the RPC, RPC Subscriptions and airdrop function.\nconst rpc = createSolanaRpc(\"http://127.0.0.1:8899\");\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\"ws://127.0.0.1:8900\");\nconst airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n// Generate a new wallet with 1 SOL.\nconst wallet = await generateKeyPairSigner();\nawait airdrop({\n  recipientAddress: wallet.address,\n  lamports: lamports(1_000_000_000n),\n  commitment: \"confirmed\",\n});\n</code></pre>"},{"location":"getting-started/generate-signer/#adjust-our-client-object","title":"Adjust our <code>Client</code> object","text":"<p>Since we're going to rely on this signer for the rest of the tutorial, let's adjust our <code>Client</code> object to include it.</p> src/client.ts<pre><code>import {\n  airdropFactory,\n  generateKeyPairSigner,\n  lamports,\n  MessageSigner,\n  TransactionSigner,\n} from \"@solana/kit\";\n\nexport type Client = {\n  rpc: Rpc&lt;SolanaRpcApi&gt;;\n  rpcSubscriptions: RpcSubscriptions&lt;SolanaRpcSubscriptionsApi&gt;;\n  wallet: TransactionSigner &amp; MessageSigner;\n};\n\nlet client: Client | undefined;\nexport async function createClient(): Promise&lt;Client&gt; {\n  if (!client) {\n    // Create RPC objects and airdrop function.\n    const rpc = createSolanaRpc(\"http://127.0.0.1:8899\");\n    const rpcSubscriptions = createSolanaRpcSubscriptions(\n      \"ws://127.0.0.1:8900\"\n    );\n    const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n    // Create a wallet with lamports.\n    const wallet = await generateKeyPairSigner();\n    await airdrop({\n      recipientAddress: wallet.address,\n      lamports: lamports(1_000_000_000n),\n      commitment: \"confirmed\",\n    });\n\n    // Store the client.\n    client = { rpc, rpcSubscriptions, wallet };\n  }\n  return client;\n}\n</code></pre> <p>Notice how we had to make the <code>createClient</code> function asynchronous since it now contains asynchronous code to generate the <code>KeyPairSigner</code> and airdrop lamports to it. That means, we also need to adjust our main <code>tutorial</code> function accordingly. And whilst we're at it, let's display the balance of our newly created wallet.</p> src/index.ts<pre><code>async function tutorial() {\n  const client = await createClient();\n  const { value: balance } = await client.rpc\n    .getBalance(client.wallet.address)\n    .send();\n  console.log(`Balance: ${balance} lamports.`);\n}\n</code></pre> <p>We've now got everything we need to start crafting transactions! In the next article, we'll build instructions that create a new token on Solana.</p>"},{"location":"getting-started/getting-started/","title":"Getting started with Kit","text":"<p>In this series of articles, we'll build a simple application that creates a new Solana token and retrieves its information. Along the way, we'll explore some of the core concepts of the Kit library and learn how to use it to send transactions and read data from the Solana blockchain.</p> <p>Let's start by setting up our project!</p> <p>You can find all the articles of this series listed below.</p> <ul> <li> <p>Set up you project Set up the environment and prepare a personalised client object</p> </li> <li> <p>Generate a signer Create a new keypair signer and airdrop lamports to it</p> </li> <li> <p>Create instructions Create instructions that creates a new Solana token</p> </li> <li> <p>Build a transaction Construcy a new trannsaction message and sign it</p> </li> <li> <p>Send a transaction Send a new transaction to the blockchain and wait for its confirmation</p> </li> <li> <p>Fetch an account Fetch and decode on-chain accounts</p> </li> </ul>"},{"location":"getting-started/send-transaction/","title":"Send a transaction","text":"<p>In the previous article, we constructed a signed transaction that creates a Solana token. Now, let's see how we can send this transaction and ensure it has been confirmed by the network.</p>"},{"location":"getting-started/send-transaction/#send-transactions-without-confirming","title":"Send transactions without confirming","text":"<p>The most common way to send transactions is via the <code>sendTransaction</code> RPC method. This method accepts an encoded signed transaction and forwards it to the configured RPC node so it can handle this for us.</p> <p>One way to tackle this would be to encode the transaction ourselves using <code>getBase64EncodedWireTransaction</code> and pass it to the <code>sendTransaction</code> RPC method like so.</p> <pre><code>import { getBase64EncodedWireTransaction } from \"@solana/kit\";\n\nconst encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\nawait rpc\n  .sendTransaction(encodedTransaction, {\n    preflightCommitment: \"confirmed\",\n    encoding: \"base64\",\n  })\n  .send();\n</code></pre> <p>However, Kit offers a helper function that does that for us whilst providing some sensible default values. This function is called <code>sendTransactionWithoutConfirmingFactory</code> and, given an RPC object, it returns a function that sends transactions without waiting for confirmation.</p> <pre><code>import { sendTransactionWithoutConfirmingFactory } from \"@solana/kit\";\n\nconst sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\nawait sendTransaction(signedTransaction, { commitment: \"confirmed\" });\n</code></pre>"},{"location":"getting-started/send-transaction/#confirmation-strategies","title":"Confirmation strategies","text":"<p>Sending transactions is one thing but, more often than not, we'll want to make sure they have been processed by the network before we continue with our application logic.</p> <p>There are several ways to ensure a transaction was confirmed by the network. For instance, we could poll the network at regular intervals to check the status of the transaction until it has the required commitment level. Another way would be to listen for network events and use them to determine the status of the sent transaction.</p> <p>Sometimes it may be useful to dig deeper into confirmation strategies and create custom ones that make the most sense for our applications. But for all other cases, Kit provides helpers that abstract this complexity away from us. Namely, it provides two helper functions that both send and confirm transactions. Which function to use depends on the lifetime set on the transaction.</p> <ul> <li><code>sendAndConfirmTransactionFactory</code> is used for transactions using a blockhash strategy for its lifetime.</li> <li><code>sendAndConfirmDurableNonceTransactionFactory</code> is used for transactions using a durable nonce strategy for its lifetime.</li> </ul> <p>Both accept RPC and RPC Subscriptions objects and return a function that sends and confirms transactions for us. Since we are using the blockhash strategy in this tutorial, we'll use the <code>sendAndConfirmTransactionFactory</code> function.</p> <pre><code>import { sendAndConfirmTransactionFactory } from \"@solana/kit\";\n\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n  rpc,\n  rpcSubscriptions,\n});\nawait sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n</code></pre>"},{"location":"getting-started/send-transaction/#transaction-signatures","title":"Transaction signatures","text":"<p>If you hover on top of the <code>sendTransaction</code> or <code>sendAndConfirmTransaction</code> functions above, you'll notice that their return type is simply <code>Promise&lt;void&gt;</code>. That is, they do not return the transaction signature that uniquely identifies that transaction on the network.</p> <p>This is because there is a common misconception that one must wait for the transaction to be sent to the network before obtaining its signature. However, that's not the case. The transaction signature is accessible as soon as the transaction is signed by its fee payer. This is because the signature that uniquely identifies a transaction is none other than the fee payer's signature for that transaction.</p> <p>As such, Kit decouples these two distinct concepts by offering a <code>getSignatureFromTransaction</code> function that returns the signature of a transaction that can be used even before it is sent to the network.</p> <pre><code>import {\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n} from \"@solana/kit\";\n\n// Access the transaction signature.\nconst signature = getSignatureFromTransaction(signedTransaction);\n\n// Send and confirm the transaction.\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n  rpc,\n  rpcSubscriptions,\n});\nawait sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n</code></pre>"},{"location":"getting-started/send-transaction/#update-clientts","title":"Update <code>client.ts</code>","text":"<p>With all that new knowledge in hand, let's update our <code>Client</code> object to include the new <code>sendAndConfirmTransaction</code> function created from the <code>sendAndConfirmTransactionFactory</code> helper.</p> src/clien.ts<pre><code>  import {\n+   sendAndConfirmTransactionFactory,\n    // ...\n  } from \"@solana/kit\";\n\n  export type Client = {\n    estimateAndSetComputeUnitLimit: &lt;T extends CompilableTransactionMessage&gt;(transactionMessage: T) =&gt; Promise&lt;T&gt;;\n    rpc: Rpc&lt;SolanaRpcApi&gt;;\n    rpcSubscriptions: RpcSubscriptions&lt;SolanaRpcSubscriptionsApi&gt;;\n+   sendAndConfirmTransaction: ReturnType&lt;typeof sendAndConfirmTransactionFactory&gt;;\n    wallet: TransactionSigner &amp; MessageSigner;\n  };\n\n  let client: Client | undefined;\n  export async function createClient(): Promise&lt;Client&gt; {\n    if (!client) {\n      // ...\n\n+     // Create a function to send and confirm transactions.\n+     const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n\n      // Store the client.\n      client = {\n        estimateAndSetComputeUnitLimit,\n        rpc,\n        rpcSubscriptions,\n+       sendAndConfirmTransaction,\n        wallet,\n      };\n    }\n    return client;\n  }\n</code></pre>"},{"location":"getting-started/send-transaction/#update-create-mintts","title":"Update <code>create-mint.ts</code>","text":"<p>Now, let's make use of our new <code>client.sendAndConfirmTransaction</code> helper in the <code>createMint</code> function.</p> <p>All that's left to do is return the address of the <code>Mint</code> account we created so the caller of this function can use it for further operations.</p> <p>And with that, our <code>createMint</code> function is complete!</p> src/create-mint.ts<pre><code>  import {\n    appendTransactionMessageInstructions,\n    createTransactionMessage,\n    generateKeyPairSigner,\n    pipe,\n    setTransactionMessageFeePayerSigner,\n    setTransactionMessageLifetimeUsingBlockhash,\n    signTransactionMessageWithSigners,\n  } from \"@solana/kit\";\n  import { getCreateAccountInstruction } from \"@solana-program/system\";\n  import { getInitializeMintInstruction, getMintSize, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\n\n  import type { Client } from \"./client\";\n\n  export async function createMint(client: Client, options: { decimals?: number } = {}) {\n    // Prepare inputs.\n    const mintSize = getMintSize();\n    const [mint, mintRent, { value: latestBlockhash }] = await Promise.all([\n      generateKeyPairSigner(),\n      client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n      client.rpc.getLatestBlockhash().send(),\n    ]);\n\n    // Build instructions.\n    const createAccountIx = getCreateAccountInstruction({\n      payer: client.wallet,\n      newAccount: mint,\n      space: mintSize,\n      lamports: mintRent,\n      programAddress: TOKEN_PROGRAM_ADDRESS,\n    });\n    const initializeMintIx = getInitializeMintInstruction({\n      mint: mint.address,\n      decimals: options.decimals ?? 0,\n      mintAuthority: client.wallet.address,\n      freezeAuthority: client.wallet.address,\n    });\n\n    // Build the transaction message.\n    const transactionMessage = await pipe(\n      createTransactionMessage({ version: 0 }),\n      (tx) =&gt; setTransactionMessageFeePayerSigner(client.wallet, tx),\n      (tx) =&gt; setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n      (tx) =&gt; appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n      (tx) =&gt; client.estimateAndSetComputeUnitLimit(tx),\n    );\n\n    // Compile the transaction message and sign it.\n    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n\n    // Send the transaction and wait for confirmation.\n+   await client.sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n\n+   // Return the address of the created mint account.\n+   return mint.address;\n  }\n</code></pre>"},{"location":"getting-started/send-transaction/#update-indexts","title":"Update <code>index.ts</code>","text":"<p>Finally, let's update our main <code>tutorial</code> function to execute the <code>createMint</code> function and log the address of the newly created mint account.</p> src/index.ts<pre><code>import { createClient } from \"./client\";\nimport { createMint } from \"./create-mint\";\n\nasync function tutorial() {\n  const client = await createClient();\n  const mintAddress = await createMint(client, { decimals: 2 });\n  console.log(`Mint created: ${mintAddress}.`);\n}\n</code></pre> <p>On the next article, we'll use that address to fetch and decode the mint account we just created.</p>"},{"location":"getting-started/set-up-project/","title":"Set up your project","text":""},{"location":"getting-started/set-up-project/#install-dependencies","title":"Install dependencies","text":"<p>First things first, set up a new TypeScript project with a <code>src/index.ts</code> file and install the <code>@solana/kit</code> library. Additionally, to keep this tutorial focused on the Kit library, we'll use <code>tsx</code> to compile and run our TypeScript code.</p> npmyarnpnpmbun <pre><code>npm instal --save @solana/kit tsx\n</code></pre> <pre><code>yarn add @solana/kit tsx\n</code></pre> <pre><code>pnpm add @solana/kit tsx\n</code></pre> <pre><code>bun add @solana/kit tsx\n</code></pre>"},{"location":"getting-started/set-up-project/#add-some-scripts","title":"Add some scripts","text":"<p>Let's also create a <code>start</code> script that runs <code>tsx src/index.ts</code> and a <code>validator</code> script to start a local Solana validator. Your <code>package.json</code> should look something like this:</p> package.json<pre><code>{\n  \"name\": \"kit-tutorial\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"tsx src/index.ts\",\n    \"validator\": \"solana-test-validator\"\n  },\n  \"dependencies\": {\n    \"@solana/kit\": \"^2.1.0\",\n    \"tsx\": \"^4.19.3\"\n  }\n}\n</code></pre> <p>From now on, we just need to make sure a Solana validator is running using the <code>validator</code> script before we can run our <code>start</code> script.</p>"},{"location":"getting-started/set-up-project/#create-a-client-object","title":"Create a client object","text":"<p>To simplify our development, we'll create a small <code>Client</code> type specific to our application. Meaning it will include all the necessary objects and functions we need to interact with Solana.</p> <p>The first two things we need are the RPC and RPC Subscriptions objects which allow us to send requests to the network and listen for network events respectively. We'll need both of them to fetch accounts and send transactions.</p> <p>Let's create a new <code>src/client.ts</code> file and add the following <code>Client</code> type:</p> <pre><code>import {\n  Rpc,\n  RpcSubscriptions,\n  SolanaRpcApi,\n  SolanaRpcSubscriptionsApi,\n} from \"@solana/kit\";\n\nexport type Client = {\n  rpc: Rpc&lt;SolanaRpcApi&gt;;\n  rpcSubscriptions: RpcSubscriptions&lt;SolanaRpcSubscriptionsApi&gt;;\n};\n</code></pre> <p>Then, let's create a helper function to create a new cached <code>Client</code> object that we can use throughout our application:</p> <pre><code>import { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nlet client: Client | undefined;\nexport function createClient(): Client {\n  if (!client) {\n    client = {\n      rpc: createSolanaRpc(\"http://127.0.0.1:8899\"),\n      rpcSubscriptions: createSolanaRpcSubscriptions(\"ws://127.0.0.1:8900\"),\n    };\n  }\n  return client;\n}\n</code></pre> <p>We'll add more to this <code>Client</code> type as we progress through the tutorial but for now, this is all we need to get started.</p>"},{"location":"getting-started/set-up-project/#run-the-tutorial","title":"Run the tutorial","text":"<p>Finally, let's go back to our <code>src/index.ts</code> file and add an asynchronous <code>tutorial</code> function that we will run immediately to start our tutorial. For now, let's just use our <code>Client</code> object to fetch the balance of a specific account.</p> <p>We can do this by creating an <code>Address</code> type via the <code>address</code> helper and fetching the balance via the <code>getBalance</code> method of the <code>rpc</code> object.</p> <pre><code>import { address } from \"@solana/kit\";\nimport { createClient } from \"./client\";\n\n// Run the tutorial.\ntutorial();\n\nasync function tutorial() {\n  const client = createClient();\n  const account = address(\"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\");\n  const { value: balance } = await client.rpc.getBalance(account).send();\n  console.log(`Balance: ${balance} lamports.`);\n}\n</code></pre> <p>You should now see something like this when you run the <code>start</code> script:</p> <pre><code>Balance: 1141440 lamports.\n</code></pre> <p>In the next article, we'll learn how to generate a wallet that can spend lamports and sign transactions.</p>"}]}